FRAGENPOOL = [
    {
        "id": "m2_1",
        "typ": "single_choice",
        "frage": "Welche Aussage beschreibt die Bedeutung des Lesens laut Pr√§sentation am besten?",
        "optionen": ["Lesen ist ein Werkzeug der Leistungskontrolle", "Lesen ist eine Schl√ºsselkompetenz f√ºr Bildung", "Lesen wird durch Schreiben ersetzt", "Lesen ist in digitalen Medien unwichtig"],
        "antwort": "Lesen ist eine Schl√ºsselkompetenz f√ºr Bildung",
        "gewichtung": 1
    },
    {
        "id": "m2_2",
        "typ": "zuordnung",
        "frage": "Ordne die Lesestrategien den passenden Phasen im Lesestrategieprozess zu.",
        "paare": [
            ["Vor dem Lesen", ["W-Fragen stellen", "Titel untersuchen", "Markieren"]],
            ["W√§hrend des Lesens", ["Markieren", "Randnotizen", "Zusammenfassen"]],
            ["Nach dem Lesen", ["Zusammenfassen", "Stellung nehmen", "Titel untersuchen"]]
        ],
        "antworten": ["W-Fragen stellen", "Markieren", "Zusammenfassen"],
        "gewichtung": 2
    },
    {
        "id": "m2_3",
        "typ": "szenario",
        "frage": "Eine Lehrkraft analysiert die Leseleistungen ihrer Klasse und stellt fest, dass viele Sch√ºler:innen keine Textebenen unterscheiden k√∂nnen. Worauf deutet das hin?",
        "optionen": ["Sie lesen zu schnell", "Sie k√∂nnen den Sinn global nicht erfassen", "Sie haben Rechtschreibprobleme", "Sie sprechen nicht genug"],
        "antwort": "Sie k√∂nnen den Sinn global nicht erfassen",
        "gewichtung": 1
    },
    {
        "id": "m2_4",
        "typ": "multi_select",
        "frage": "Welche Merkmale beschreiben laut PISA typische Leseschwierigkeiten?",
        "optionen": ["Wortgenauigkeit", "Geringe Lesemotivation", "Fehlende Lesefl√ºssigkeit", "Guter Ausdrucksreichtum"],
        "antworten": ["Wortgenauigkeit", "Geringe Lesemotivation", "Fehlende Lesefl√ºssigkeit"],
        "gewichtung": 1
    },
    {
        "id": "m2_5",
        "typ": "offen",
        "frage": "Warum ist das Mehrebenenmodell von Rosebrock & Nix hilfreich f√ºr die Planung von Leseunterricht?",
        "gewichtung": 2
    },
    {
        "id": "m2_6",
        "typ": "single_choice",
        "frage": "Was ist ein zentrales Prinzip der SMART-Lesen-Methode?",
        "optionen": ["Texte vollst√§ndig laut lesen", "Strategien in denkbare Mini-Schritte aufteilen", "Lesezeit verk√ºrzen", "Vorlesen durch Apps ersetzen"],
        "antwort": "Strategien in denkbare Mini-Schritte aufteilen",
        "gewichtung": 1
    },
    {
        "id": "m2_7",
        "typ": "szenario",
        "frage": "Ein Sch√ºler liest fl√ºssig, aber versteht Inhalte nur oberfl√§chlich. Welche Methode kann helfen?",
        "optionen": ["Laut vorlesen lassen", "Wortspeicher erstellen", "Frontread-Training zur Lesegenauigkeit", "Mehr Diktate schreiben"],
        "antwort": "Frontread-Training zur Lesegenauigkeit",
        "gewichtung": 1
    },
    {
        "id": "m2_8",
        "typ": "single_choice",
        "frage": "Welche Methode eignet sich besonders zur F√∂rderung des sinnentnehmenden Lesens bei schw√§cheren Sch√ºler:innen?",
        "optionen": ["Klappentext schreiben", "Lautes Vorlesen", "Tandemlesen", "Grammatik√ºbungen"],
        "antwort": "Tandemlesen",
        "gewichtung": 1
    },
    {
        "id": "m2_9",
        "typ": "zuordnung",
        "frage": "Ordne den Lesef√∂rderprogrammen das jeweilige Hauptziel zu:",
        "paare": [
            ["FiLBY", ["F√∂rderung von Lesestrategien", "Lesemotivation", "Lesefl√ºssigkeit"]],
            ["Antolin", ["Lesemotivation", "Strategiewissen", "Vorlesen"]],
            ["Frontread", ["Lesefl√ºssigkeit", "Lautlesemethoden", "Texterg√§nzung"]]
        ],
        "antworten": ["F√∂rderung von Lesestrategien", "Lesemotivation", "Lesefl√ºssigkeit"],
        "gewichtung": 2
    },
    {
        "id": "m2_10",
        "typ": "offen",
        "frage": "Welche konkreten Ma√ünahmen kann eine Lehrkraft ergreifen, um leseschwache Sch√ºler:innen individuell zu f√∂rdern?",
        "gewichtung": 2
    },
    {
        "id": "m2_11",
        "typ": "single_choice",
        "frage": "Wof√ºr ist der Ratte-Test geeignet?",
        "optionen": ["Lautlesetempo messen", "Wortschatz √ºberpr√ºfen", "Grammatik √ºben", "Rechtschreibung bewerten"],
        "antwort": "Lautlesetempo messen",
        "gewichtung": 1
    },
    {
        "id": "m2_12",
        "typ": "szenario",
        "frage": "Eine Klasse hat Schwierigkeiten, beim Lesen von Sachtexten relevante Informationen zu filtern. Welche Ma√ünahme ist besonders geeignet?",
        "optionen": ["Erz√§hltexte statt Sachtexte nutzen", "Mindmaps zum Text erstellen", "Texte mehrfach diktieren", "Alle Abschnitte abschreiben"],
        "antwort": "Mindmaps zum Text erstellen",
        "gewichtung": 1
    },
    {
        "id": "m2_13",
        "typ": "zuordnung",
        "frage": "Ordne Diagnoseverfahren der passenden F√∂rderma√ünahme zu:",
        "paare": [
            ["Geringe Fl√ºssigkeit", ["Lautlese-Tandem", "Kontextarbeit", "Textanalyse"]],
            ["Wortverst√§ndnis fehlt", ["Kontext-Training", "Nacherz√§hlen", "Lautlesen"]],
            ["Inhalt unklar", ["Visualisieren", "Lautlese-Tandem", "Abschreiben"]]
        ],
        "antworten": ["Lautlese-Tandem", "Kontext-Training", "Visualisieren"],
        "gewichtung": 2
    },
    {
        "id": "m2_14",
        "typ": "offen",
        "frage": "Welche Vorteile hat die Arbeit mit Ganzschriften im Vergleich zu kurzen Textausschnitten?",
        "gewichtung": 2
    }
]

def bewerte_freitext_antwort(text, max_punkte):
    laenge = len(text.strip())
    if laenge >= 150:
        return max_punkte
    elif 100 <= laenge < 150:
        return round(max_punkte / 2)
    else:
        return 0


import streamlit as st
import random
import json
import os
from datetime import datetime
from fpdf import FPDF

# === KONFIGURATION ===
st.set_page_config(page_title="Interaktiver Test ‚Äì Modul 2", page_icon="üìù")
st.title("üìù Interaktiver Test zu Modul 2: Lesen ‚Äì mit Texten und weiteren Medien umgehen")



# Hinweis: Funktionaler Teil (Fortschritt, Anzeige, Bewertung, Zertifikat) folgt im n√§chsten Teil des Skripts

# === FORTSCHRITT & ANTWORTSPEICHERUNG ===
ANTWORT_DATEI = "antworten_{user}.json"
FORTSCHRITT_DATEI = "fortschritt_{user}.json"

def lade_fortschritt(user):
    pfad = FORTSCHRITT_DATEI.format(user=user.replace(" ", "_"))
    if os.path.exists(pfad):
        with open(pfad, "r", encoding="utf-8") as f:
            return json.load(f)
    return {"seite": 0, "punkte": 0, "beantwortet": [], "offene_antworten": []}

def speichere_fortschritt(user, daten):
    pfad = FORTSCHRITT_DATEI.format(user=user.replace(" ", "_"))
    with open(pfad, "w", encoding="utf-8") as f:
        json.dump(daten, f, indent=2, ensure_ascii=False)

def speichere_offene_antwort(user, frage_id, antworttext):
    pfad = ANTWORT_DATEI.format(user=user.replace(" ", "_"))
    daten = []
    if os.path.exists(pfad):
        with open(pfad, "r", encoding="utf-8") as f:
            daten = json.load(f)
    daten.append({"frage_id": frage_id, "antwort": antworttext, "zeit": datetime.now().strftime('%Y-%m-%d %H:%M')})
    with open(pfad, "w", encoding="utf-8") as f:
        json.dump(daten, f, indent=2, ensure_ascii=False)

# === ZERTIFIKAT-KLASSE ===
class ZertifikatPDF(FPDF):
    def header(self):
        self.set_fill_color(240, 248, 255)
        self.rect(10, 10, 190, 277, 'F')
        self.set_draw_color(70, 70, 160)
        self.set_line_width(1)
        self.rect(10, 10, 190, 277)
        self.set_font("Arial", "B", 28)
        self.set_text_color(40, 40, 100)
        self.ln(20)
        self.cell(0, 20, "Zertifikat Modul 2: Lesen", ln=True, align='C')
        self.ln(5)
        self.set_font("Arial", "I", 14)
        self.set_text_color(80, 80, 80)
        self.cell(0, 10, "f√ºr besondere Leistungen im Kompetenzbereich Lesen", ln=True, align='C')
        self.ln(10)

    def footer(self):
        self.set_y(-40)
        self.set_font("Arial", "I", 12)
        self.set_text_color(60, 60, 60)
        self.cell(0, 10, "Dozent:innen: Marcus M√ºller, Christiane Riehn-Wild", ln=True, align='C')
        self.set_font("Arial", "I", 10)
        self.cell(0, 10, "Modul 2 - Interaktiver Test zum Kompetenzbereich Lesen", 0, 0, 'C')

    def zertifikat_content(self, name, punkte, max_punkte, datum):
        if punkte >= 16:
            bewertung = "mit herausragendem Erfolg"
        elif punkte >= 12:
            bewertung = "mit gutem Erfolg"
        elif punkte >= 7:
            bewertung = "mit Erfolg"
        else:
            bewertung = "mit wenig Erfolg"

        self.set_y(90)
        self.set_font("Arial", "", 16)
        self.set_text_color(0, 0, 0)
        text = f"""Hiermit wird best√§tigt, dass

{name}

am interaktiven Test
'Modul 2: Lesen - mit Texten und weiteren Medien umgehen'
{bewertung} teilgenommen hat."""
        self.multi_cell(0, 10, text, align='C')
        self.ln(10)
        self.set_font("Arial", "B", 14)
        self.cell(0, 10, f"Punktzahl: {punkte} / {max_punkte}", ln=True, align='C')
        self.cell(0, 10, f"Datum: {datum}", ln=True, align='C')
# Hinweis: Die restliche Interaktionslogik (Fragenanzeige & Adminbereich) folgt hier im Live-Skript
# Sie wurde bereits vorher im Projekt entwickelt und kann direkt erg√§nzt werden.

# === START TEST ===
user = st.text_input("Bitte gib deinen vollst√§ndigen Namen ein:")

if user:
    if "fortschritt" not in st.session_state:
        st.session_state.fortschritt = lade_fortschritt(user)
        st.session_state.fragenliste = FRAGENPOOL
        random.shuffle(st.session_state.fragenliste)
        st.session_state.user = user

    fortschritt = st.session_state.fortschritt
    fragenliste = st.session_state.fragenliste
    seite = fortschritt["seite"]

    if seite >= len(fragenliste):
        st.success("üéâ Du hast den Test abgeschlossen!")
        st.info(f"Erreichte Punktzahl: {fortschritt['punkte']} von {sum(f['gewichtung'] for f in fragenliste)}")
        if st.button("üìÑ Zertifikat erstellen"):
            cert = ZertifikatPDF()
            cert.add_page()
            cert.zertifikat_content(user, fortschritt["punkte"], sum(f["gewichtung"] for f in fragenliste), datetime.now().strftime('%d.%m.%Y'))
            filename = f"zertifikat_{user.replace(' ', '_')}.pdf"
            cert.output(filename)
            with open(filename, "rb") as file:
                st.download_button("Zertifikat herunterladen", file, file_name=filename)
    else:
        frage = fragenliste[seite]
        st.subheader(f"Frage {seite + 1} von {len(fragenliste)}")
        st.write(f"**{frage['frage']}**")

        key_base = f"{frage['id']}_{seite}"
        if f"antwort_bestaetigt_{key_base}" not in st.session_state:
            st.session_state[f"antwort_bestaetigt_{key_base}"] = False
            st.session_state[f"antwort_korrekt_{key_base}"] = False

        antwort_bestaetigt = st.session_state[f"antwort_bestaetigt_{key_base}"]

        if not antwort_bestaetigt:
            if frage["typ"] == "single_choice":
                auswahl = st.radio("Bitte ausw√§hlen:", frage["optionen"], key=f"{key_base}_radio")
                if st.button("Antwort best√§tigen", key=f"btn_{key_base}"):
                    if auswahl == frage["antwort"]:
                        st.success("‚úÖ Richtig!")
                        st.session_state[f"antwort_korrekt_{key_base}"] = True
                    else:
                        st.error("‚ùå Falsch.")
                        st.info(f"‚úÖ Richtige Antwort: **{frage['antwort']}**")
                    st.session_state[f"antwort_bestaetigt_{key_base}"] = True

            elif frage["typ"] == "multi_select":
                auswahl = st.multiselect("W√§hle alle zutreffenden Optionen:", frage["optionen"], default=[], key=f"{key_base}_multi")
                if st.button("Antwort best√§tigen", key=f"btn_{key_base}"):
                    if set(auswahl) == set(frage["antworten"]):
                        st.success("‚úÖ Richtig!")
                        st.session_state[f"antwort_korrekt_{key_base}"] = True
                    else:
                        st.error("‚ùå Nicht korrekt.")
                        st.info(f"‚úÖ Richtige Antworten: **{', '.join(frage['antworten'])}**")
                    st.session_state[f"antwort_bestaetigt_{key_base}"] = True

            elif frage["typ"] == "zuordnung":
                antworten = []
                for i, (frage_text, optionen) in enumerate(frage["paare"]):
                    antworten.append(st.selectbox(frage_text, [""] + optionen, key=f"{key_base}_{i}"))
                if st.button("Antwort best√§tigen", key=f"btn_{key_base}"):
                    if antworten == frage["antworten"]:
                        st.success("‚úÖ Richtig zugeordnet!")
                        st.session_state[f"antwort_korrekt_{key_base}"] = True
                    else:
                        st.error("‚ùå Falsch zugeordnet.")
                        st.info(f"‚úÖ Richtige Zuordnung: **{', '.join(frage['antworten'])}**")
                    st.session_state[f"antwort_bestaetigt_{key_base}"] = True

            elif frage["typ"] == "szenario":
                auswahl = st.radio("W√§hle die beste Ma√ünahme:", frage["optionen"], key=f"{key_base}_radio")
                if st.button("Antwort best√§tigen", key=f"btn_{key_base}"):
                    if auswahl == frage["antwort"]:
                        st.success("‚úÖ Richtig!")
                        st.session_state[f"antwort_korrekt_{key_base}"] = True
                    else:
                        st.error("‚ùå Nicht korrekt.")
                        st.info(f"‚úÖ Richtige Antwort: **{frage['antwort']}**")
                    st.session_state[f"antwort_bestaetigt_{key_base}"] = True

            
            
            elif frage["typ"] == "offen":
                eingabe = st.text_area("Deine Antwort:", key=f"{key_base}_text")
                if st.button("Antwort speichern", key=f"btn_{key_base}"):
                    if eingabe.strip():
                        speichere_offene_antwort(user, frage["id"], eingabe.strip())
                        punkte = bewerte_freitext_antwort(eingabe.strip(), frage["gewichtung"])
                        if punkte > 0:
                            st.success(f"Antwort gespeichert und mit {punkte} Punkt(en) bewertet.")
                            fortschritt["punkte"] += punkte
                        else:
                            st.warning("Antwort zu kurz ‚Äì keine Punkte vergeben.")
                        speichere_fortschritt(user, fortschritt)
                        st.session_state[f"antwort_korrekt_{key_base}"] = True
                        st.session_state[f"antwort_bestaetigt_{key_base}"] = True
                    else:
                        st.warning("Bitte gib eine Antwort ein.")

                elif st.session_state.get(f"antwort_bestaetigt_{key_base}", False):
                    if st.button("‚û°Ô∏è Weiter zur n√§chsten Frage", key=f"weiter_{key_base}"):
                        fortschritt["seite"] += 1
                        speichere_fortschritt(user, fortschritt)
                        st.session_state.pop(f"antwort_bestaetigt_{key_base}", None)
                        st.session_state.pop(f"antwort_korrekt_{key_base}", None)
                        st.rerun()



        else:
            if st.button("‚û°Ô∏è Weiter zur n√§chsten Frage", key=f"weiter_{key_base}"):
                if st.session_state[f"antwort_korrekt_{key_base}"] and frage["typ"] != "offen":
                    fortschritt["punkte"] += frage["gewichtung"]
                fortschritt["seite"] += 1
                speichere_fortschritt(user, fortschritt)
                st.session_state.pop(f"antwort_bestaetigt_{key_base}", None)
                st.session_state.pop(f"antwort_korrekt_{key_base}", None)
                st.rerun()

# === ADMINBEREICH (mit Passwortschutz) ===
import glob

st.sidebar.title("üîê Adminbereich")

admin_pass = st.sidebar.text_input("Passwort eingeben:", type="password")

if admin_pass == "Modul2":  # Passwort hier setzen
    if st.sidebar.checkbox("Offene Antworten anzeigen"):
        user_files = [f for f in os.listdir() if f.startswith("antworten_") and f.endswith(".json")]
        for file in user_files:
            st.sidebar.markdown(f"### üßë {file.replace('antworten_', '').replace('.json', '')}")
            with open(file, "r", encoding="utf-8") as f:
                daten = json.load(f)
            for eintrag in daten:
                st.sidebar.markdown(f"**{eintrag['frage_id']}** ({eintrag['zeit']}):")
                st.sidebar.code(eintrag['antwort'])

    if st.sidebar.checkbox("Punktest√§nde anzeigen"):
        fortschritt_files = [f for f in os.listdir() if f.startswith("fortschritt_") and f.endswith(".json")]
        for file in fortschritt_files:
            name = file.replace("fortschritt_", "").replace(".json", "")
            with open(file, "r", encoding="utf-8") as f:
                data = json.load(f)
            st.sidebar.write(f"{name}: {data['punkte']} Punkte, Frage {data['seite']}")

    if st.sidebar.button("üö® Alle Nutzerergebnisse l√∂schen"):
        geloescht = 0
        for file in glob.glob("antworten_*.json") + glob.glob("fortschritt_*.json"):
            try:
                os.remove(file)
                geloescht += 1
            except:
                pass
        st.sidebar.success(f"{geloescht} Dateien wurden gel√∂scht. Alle Nutzerergebnisse zur√ºckgesetzt.")
